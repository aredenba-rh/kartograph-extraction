I'm building a Knowledge Graph from technical documentation repositories in the `data/` folder. You are assigned to create a **master ontology** that will be used across all data sources.

## Your Task Assignment

**Master Ontology Creation**
- Scope: All data sources in `data/` folder
- Output files:
  - `ontologies/master_entity_ontology.json`
  - `ontologies/master_relationship_ontology.json`
- Goal: Define entity and relationship types at the optimal abstraction level for AI-assisted question answering

## Success Pattern (Follow These Steps)

1. **Survey Data Sources**: Explore the `data/` folder structure to understand what types of documentation exist
   ```bash
   find data/ -type d -maxdepth 2 | sort
   find data/ -type f -name "*.md" -o -name "*.adoc" | head -20
   ```

2. **Sample Content Analysis**: Read representative files from each data source to identify:
   - What entities appear (components, tools, errors, procedures, etc.)
   - What relationships exist between entities
   - What abstraction level would optimize query traversal

3. **Create Required Entity Types**: For each required entity type (specified below), run:
   ```bash
   python scripts/create_master_entity.py "<type>" "<description>" "<example_file>" "<example_in_file>"
   ```

4. **Create Additional Entity Types**: Identify and create additional entity types beyond the required set

5. **Create Required Relationship Types**: For each required relationship type (specified below), run:
   ```bash
   python scripts/create_master_relationship.py "<type>" "<source_entity_type>" "<target_entity_type>" "<description>" "<example_file>" "<example_in_file>"
   ```

6. **Create Additional Relationship Types**: Identify and create additional relationship types beyond the required set

7. **Mental Validation**: Before completing, verify your ontology enables efficient answers to:
   - Procedural questions ("How do I...?")
   - Troubleshooting questions ("What causes...?", "How to fix...?")
   - Location questions ("Where is...?")
   - Conceptual questions ("What is...?")
   - Ensure answers require ≤3 graph hops

8. **Complete**: Respond without tools when all entity and relationship types are defined


## Your Goal

Create a **COMPLETE** master ontology that:
- Captures ALL meaningful entity types present within and across data sources
- Captures ALL meaningful relationship types between entities
- Uses **mid-level abstraction** (specific enough for domain semantics, general enough for reusability)
- Enables efficient graph traversal for question answering (1-3 hops maximum)


## Abstraction Level: Mid-Level Semantic (CRITICAL)

Your entity and relationship types must exist at the **mid-level abstraction layer**.

### What This Means:

**TOO ABSTRACT (❌ AVOID):**
- Entity: `Thing`, `Item`, `Resource`, `Object`
- Relationship: `RELATES_TO`, `CONNECTED_WITH`, `ASSOCIATED`

**TOO SPECIFIC (❌ AVOID):**
- Entity: `ROSAClassicCluster`, `ROSAHCPCluster`, `OSDCluster` (should be: `Cluster` with `deployment_model` attribute)
- Entity: `M5XLargeInstanceType`, `M6XLargeInstanceType` (should be: `InstanceType` with `name` attribute)
- Entity: `ROSA_4_12`, `ROSA_4_13` (should be: `Product` with version in name like "ROSA 4.12")

**CORRECT ABSTRACTION (✅ TARGET):**
- Entity: `Component`, `Tool`, `Configuration`, `Procedure`, `Alert`, `Error`, `Cluster`, `Namespace`, `Pod`
- Relationship: `TROUBLESHOOTS`, `REQUIRES`, `CONFIGURES`, `RESOLVES`, `CAUSES`, `LOCATED_IN`


## Core Design Principles (CRITICAL - READ CAREFULLY)

### 1. Version Handling (NO Version Entity Type)

**DO NOT create a Version entity type.** Handle versions using these patterns:

**Pattern A - Version in Entity Name (for frequently referenced products):**
- Entity type: `Product`
- Entity instances: `ROSA 4.12`, `ROSA 4.13`, `OpenShift 4.15`
- Use when: Major product versions are frequently queried or have distinct features

**Pattern B - Version as Attribute (for version ranges/compatibility):**
- Entity type: `Component`
- Attributes: `min_version: "4.10"`, `max_version: null` (means 4.10+)
- Use when: Expressing compatibility ranges or minimum requirements

**Pattern C - Version as Attribute (for tools/utilities):**
- Entity type: `Tool`
- Attributes: `current_version: "1.2.5"`
- Use when: Tool versions change frequently, not central to queries

**Rationale:** This keeps the graph lean while preserving version information. Version entities would explode the graph size without adding query value.


### 2. Denormalize Decision Flags

Put critical decision-making attributes directly on entities, not as separate entities:
- ✅ `Procedure.manual_intervention_when = ["Different OCM orgs", "Version ≤ 4.10"]`
- ❌ NOT: `Procedure → HAS_CONSTRAINT → Constraint("Version ≤ 4.10")`

This enables fast attribute-based filtering instead of expensive graph traversal.


### 3. Self-Describing Entities

Entities should include enough context in their attributes to understand their role without traversal:
- `Symptom` should include: `affects_feature`, `affects_product`, `common_contexts`
- `Error` should include: `error_code`, `affected_components`, `severity`
- `Alert` should include: `severity`, `affects_cluster_type`, `alert_namespace`


## User-Enforced Entity and Relationship Types

**Required Entity Types** (you MUST create these):

- **KCSArticle**: Troubleshooting solutions, known issues, resolution procedures documented in knowledge-centered service articles
- **SOP**: Standard operating procedures, operational runbooks, alert response guides for SRE tasks
- **Documentation**: How-to guides, architecture documentation, tutorials, concept explanations, and reference materials

**Required Relationship Types** (you MUST create these):

- **TROUBLESHOOTS**: Links a document (KCSArticle, SOP) to the problem it helps solve (Error, Alert, Symptom)
- **DOCUMENTS**: Links a Documentation entity to the entity it describes or explains
- **CONTAINS_EXAMPLE**: Links a document to executable code snippets, commands, or configuration examples it contains


## Examples of Mid-Level Abstraction (Extrapolate to Your Data)

The following are **examples** of the abstraction level that works well. Study these patterns and extrapolate them to the content in your data sources.

### Example Operational Entities:
- `Tool` - CLI utilities, binaries, scripts (e.g., "osdctl", "rosa", "kubectl")
- `Command` - Executable commands (e.g., "osdctl cluster transfer-owner")
- `Procedure` - Multi-step operational tasks (e.g., "Transfer Cluster Ownership", "Resize Control Plane")
- `Configuration` - Settings, CRDs, policies (e.g., "Security Group Configuration", "PDB policy")

### Example Technical System Entities:
- `Component` - Services, operators, controllers (e.g., "etcd", "OAuth service", "cloud-ingress-operator")
- `Cluster` - Managed environments (e.g., "HCP Cluster", "Management Cluster")
- `CloudResource` - Cloud provider resources (e.g., "VPC", "IAM Role", "PrivateLink endpoint")
- `Namespace` - Kubernetes namespaces (e.g., "openshift-etcd", "openshift-monitoring")

### Example Problem/Solution Entities:
- `Alert` - Monitoring alerts (e.g., "UpgradeNodeDrainFailedSRE", "APISchemeStatusFailing")
- `Error` - Error codes and failures (e.g., "OAuth timeout error", "XCMSTRAT-293")
- `KnownIssue` - Documented bugs (e.g., "UI button disabled bug")
- `Symptom` - Observable problems (e.g., "Button disabled in UI", "Connection timeout")

### Example Relationship Patterns:
- `TROUBLESHOOTS` - Document provides solution for problem (e.g., `KCSArticle → TROUBLESHOOTS → Error`)
- `RESOLVES` - Action resolves problem (e.g., `Procedure → RESOLVES → Error`)
- `REQUIRES` - Entity needs prerequisite (e.g., `Procedure → REQUIRES → Permission`)
- `LOCATED_IN` - Physical/logical location (e.g., `Pod → LOCATED_IN → Namespace`)
- `CAUSES` - Failure mode (e.g., `Configuration → CAUSES → Error`)
- `EXECUTES` - Action uses tool (e.g., `Procedure → EXECUTES → Command`)
- `DOCUMENTS` - Documentation describes entity (e.g., `Documentation → DOCUMENTS → Feature`)


## Available Commands

You have access to these commands:
  - `python scripts/create_master_entity.py`
  - `python scripts/create_master_relationship.py`


## Command Usage

### Create Entity Type:
```bash
python scripts/create_master_entity.py \
  "<type>" \
  "<description>" \
  "<example_file>" \
  "<example_in_file>"
```

**Arguments:**
- `<type>`: Entity type name (e.g., "Procedure", "Component", "Alert")
- `<description>`: 1-3 sentences explaining what this entity type represents
- `<example_file>`: Path to a file where this entity appears (relative to repo root)
- `<example_in_file>`: Concrete example from the file (e.g., "Transfer Cluster Ownership")

### Create Relationship Type:
```bash
python scripts/create_master_relationship.py \
  "<type>" \
  "<source_entity_type>" \
  "<target_entity_type>" \
  "<description>" \
  "<example_file>" \
  "<example_in_file>"
```

**Arguments:**
- `<type>`: Relationship type name (e.g., "TROUBLESHOOTS", "REQUIRES")
- `<source_entity_type>`: Entity type this relationship originates from
- `<target_entity_type>`: Entity type this relationship points to
- `<description>`: 1-3 sentences explaining when to use this relationship
- `<example_file>`: Path to a file where this relationship appears
- `<example_in_file>`: Concrete example (e.g., "KCS 7120659 -> TROUBLESHOOTS -> OAuth timeout")


## Target Metrics

Aim for these ranges (quality over quantity):

**Entity Types:** 15-25 types
- Document types: 3-4
- Operational: 4-5
- Technical: 5-7
- Problem/Solution: 4-6
- Conceptual: 2-3

**Relationship Types:** 20-35 types
- Documentation: 3-4
- Troubleshooting: 5-7
- Operational: 5-7
- Architectural: 4-6
- Procedural: 3-4


## Critical Reminders

1. **NO Version entity type** - Use attributes or version-in-name pattern
2. **Denormalize decision flags** - Put critical attributes on entities, not separate nodes
3. **Make entities self-describing** - Include context attributes to minimize traversal
4. **Mid-level abstraction** - Not "Thing", not "M5XLargeInstanceType", but "InstanceType"
5. **Design for traversal** - Enable 1-3 hop queries for common question patterns
6. **Generic, reusable types** - Should work across data sources, not tied to one repository
7. **TYPES not instances** - Define the schema, don't populate the graph

Begin by surveying the data sources and sampling representative files to understand the content.
